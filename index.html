// Simple Flappy Bird Style Game (PC + Mobile Compatible)
// ---------------------------
// Drop this into an HTML file inside a <script> tag, or load as a separate JS file.
// The canvas must exist in your HTML with id="gameCanvas".

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = 400;
canvas.height = 600;

let bird = {
  x: 80,
  y: canvas.height / 2,
  width: 30,
  height: 30,
  velocity: 0,
  gravity: 0.5,
  jump: -9
};

let pipes = [];
let pipeGap = 150;
let pipeWidth = 60;
let pipeSpeed = 2;
let frame = 0;
let score = 0;
let gameOver = false;

function resetGame() {
  bird.y = canvas.height / 2;
  bird.velocity = 0;
  pipes = [];
  frame = 0;
  score = 0;
  gameOver = false;
}

function spawnPipe() {
  let topHeight = Math.floor(Math.random() * (canvas.height - pipeGap - 50)) + 20;
  let bottomY = topHeight + pipeGap;

  pipes.push({
    x: canvas.width,
    topHeight: topHeight,
    bottomY: bottomY
  });
}

// Handle PC (spacebar + click) AND mobile (touch)
function flap() {
  if (gameOver) {
    resetGame();
  } else {
    bird.velocity = bird.jump;
  }
}

document.addEventListener("keydown", (e) => {
  if (e.code === "Space") flap();
});

document.addEventListener("mousedown", flap);
document.addEventListener("touchstart", flap);

function update() {
  if (gameOver) return;

  bird.velocity += bird.gravity;
  bird.y += bird.velocity;

  // Prevent bird from falling off screen
  if (bird.y + bird.height > canvas.height || bird.y < 0) {
    gameOver = true;
  }

  // Spawn pipes every 100 frames
  if (frame % 100 === 0) {
    spawnPipe();
  }

  // Move pipes and detect collisions
  for (let i = pipes.length - 1; i >= 0; i--) {
    let p = pipes[i];
    p.x -= pipeSpeed;

    // Collision detection
    if (
      bird.x < p.x + pipeWidth &&
      bird.x + bird.width > p.x &&
      (bird.y < p.topHeight || bird.y + bird.height > p.bottomY)
    ) {
      gameOver = true;
    }

    // Score when passing pipe
    if (p.x + pipeWidth < bird.x && !p.scored) {
      score++;
      p.scored = true;
    }

    // Remove off-screen pipes
    if (p.x + pipeWidth < 0) {
      pipes.splice(i, 1);
    }
  }

  frame++;
}

function draw() {
  ctx.fillStyle = "skyblue";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw bird
  ctx.fillStyle = "yellow";
  ctx.fillRect(bird.x, bird.y, bird.width, bird.height);

  // Draw pipes
  ctx.fillStyle = "green";
  pipes.forEach((p) => {
    ctx.fillRect(p.x, 0, pipeWidth, p.topHeight);
    ctx.fillRect(p.x, p.bottomY, pipeWidth, canvas.height - p.bottomY);
  });

  // Score
  ctx.fillStyle = "black";
  ctx.font = "32px Arial";
  ctx.fillText(score, 20, 50);

  // Game Over text
  if (gameOver) {
    ctx.fillStyle = "red";
    ctx.font = "40px Arial";
    ctx.fillText("GAME OVER", 80, canvas.height / 2);
    ctx.font = "20px Arial";
    ctx.fillText("Tap or press SPACE to restart", 50, canvas.height / 2 + 40);
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
