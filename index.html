<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hex Mini-Game — Low-Poly Style</title>
<style>
  :root{
    --bg:#c6f2b6;
    --tile:#f0f0f0;
    --tile-edge:#d6a05a;
    --defender:#ff8a3d;
    --enemy:#b95a3a;
    --stroke:#222;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;}
  body{display:flex;align-items:center;justify-content:center;background:var(--bg);padding:18px;box-sizing:border-box;}
  .wrap{width:100%;max-width:920px;background:transparent;position:relative;}
  canvas{display:block;width:100%;height:auto;border-radius:10px;box-shadow: 0 8px 28px rgba(0,0,0,.12);}
  .controls{position:absolute;right:12px;top:12px;display:flex;flex-direction:column;gap:8px}
  button{background:#fff;border:2px solid #fff;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer;box-shadow:0 6px 20px rgba(0,0,0,.08)}
  button.secondary{background:transparent;border:2px solid rgba(0,0,0,.12)}
  .hud{position:absolute;left:12px;top:12px;background:rgba(255,255,255,0.9);padding:8px 10px;border-radius:10px;display:flex;gap:10px;align-items:center}
  .hud b{font-size:14px}
  .overlay{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    pointer-events:none;opacity:0;transition:opacity .18s;
  }
  .overlay.show{opacity:1;pointer-events:auto}
  .message{
    background:linear-gradient(180deg,#fff,#ffd8d8);border-radius:18px;padding:22px 28px;box-shadow:0 10px 40px rgba(0,0,0,.2);
    border:6px solid #5b1b1b; text-align:center;
  }
  .message h1{margin:0;font-size:56px;color:#ff1f1f;letter-spacing:2px;font-family:Impact,Arial Black,Arial;}
  .message p{margin:.5rem 0 0;color:#333}
  .credits{position:absolute;left:12px;bottom:12px;background:rgba(255,255,255,0.85);padding:6px 8px;border-radius:8px;font-size:12px}
  @media (max-width:520px){
    .message h1{font-size:36px}
    .controls{right:8px;top:8px}
    .hud{left:8px;top:8px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>

    <div class="controls">
      <button id="spawnBtn">Spawn Wave</button>
      <button id="resetBtn" class="secondary">Reset</button>
    </div>

    <div class="hud">
      <div><b>Defenders:</b> <span id="defCount">0</span></div>
      <div><b>Enemies:</b> <span id="enemyCount">0</span></div>
    </div>

    <div class="overlay" id="overlay">
      <div class="message">
        <h1>YOU LOSE</h1>
        <p>Enemies reached your center. Refresh or press Reset to try again.</p>
      </div>
    </div>

    <div class="credits">Low-poly hex demo • Click tiles to place defenders (max 8)</div>
  </div>

<script>
/*
  Hex mini-game
  - Axial coordinates (q, r) for hex grid
  - Simple greedy movement: enemy moves one step closer to center each tick
  - If enemy reaches center tile (0,0) => lose overlay
  - Click empty tile to place a defender (orange). Defenders block enemies.
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', {alpha: false});
const spawnBtn = document.getElementById('spawnBtn');
const resetBtn = document.getElementById('resetBtn');
const defCountEl = document.getElementById('defCount');
const enemyCountEl = document.getElementById('enemyCount');
const overlay = document.getElementById('overlay');

let DPR = Math.max(1, window.devicePixelRatio || 1);

let gridRadius = 3;         // radius of hex map (3 -> center + rings)
let hexSize = 42;           // will be scaled by DPR & canvas width responsively
let grid = {};              // key "q,r" -> tile object
let defenders = {};         // "q,r" -> true
let enemies = {};           // id -> {q,r}
let nextEnemyId = 1;
let maxDefenders = 8;
let tickInterval = 450;     // ms
let tickTimer = null;
let running = true;

// -------- utility: axial coords & hex math ----------
function key(q,r){ return q + ',' + r; }
function parseKey(k){ const [q,r] = k.split(',').map(Number); return {q,r}; }
function hexDistance(a,b){ return (Math.abs(a.q-b.q) + Math.abs(a.q + a.r - b.q - b.r) + Math.abs(a.r-b.r))/2; }
// neighbors (axial)
const NEI = [[+1,0],[+1,-1],[0,-1],[-1,0],[-1,+1],[0,+1]];

// ---------- responsive layout ----------
function resizeCanvas(){
  const rect = canvas.parentElement.getBoundingClientRect();
  const w = Math.min(920, rect.width);
  const h = Math.min(800, rect.height);
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(w * DPR);
  canvas.height = Math.floor(h * DPR);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';

  // set hex size to fit canvas
  // rough fit: width approx (3 * hexSize * 2) for radius 3; tune factor
  const approxCols = (gridRadius * 2 + 1);
  hexSize = Math.max(26, Math.min(62, (w * 0.9) / (approxCols * 1.1)));
  draw();
}
window.addEventListener('resize', resizeCanvas);

// ---------- build grid ----------
function buildGrid(){
  grid = {};
  defenders = {};
  enemies = {};
  nextEnemyId = 1;
  for (let q = -gridRadius; q <= gridRadius; q++){
    for (let r = -gridRadius; r <= gridRadius; r++){
      if (Math.abs(q + r) <= gridRadius){
        grid[key(q,r)] = {q,r, type: 'empty'};
      }
    }
  }
}

// axial to pixel (pointy-top hex)
function hexToPixel(q,r){
  const s = hexSize * DPR;
  const width = Math.sqrt(3) * s;
  const x = width * (q + r/2) + canvas.width/2;
  const y = (3/2) * s * r + canvas.height/2;
  return {x,y};
}
function pixelToHex(px,py){
  // convert screen px to axial coords (approx) using inverse transform then round
  const s = hexSize * DPR;
  const width = Math.sqrt(3) * s;
  // translate to grid origin center
  const x = px - canvas.width/2;
  const y = py - canvas.height/2;
  // fractional axial
  const qf = (Math.sqrt(3)/3 * x - 1/3 * y) / s;
  const rf = (2/3 * y) / s;
  return hexRound(qf, rf);
}
function hexRound(qf, rf){
  // convert fractional axial to cube coords, round, then back to axial
  const xf = qf, zf = rf, yf = -xf - zf;
  let rx = Math.round(xf), ry = Math.round(yf), rz = Math.round(zf);
  const xdiff = Math.abs(rx - xf), ydiff = Math.abs(ry - yf), zdiff = Math.abs(rz - zf);
  if (xdiff > ydiff && xdiff > zdiff) rx = -ry - rz;
  else if (ydiff > zdiff) ry = -rx - rz;
  else rz = -rx - ry;
  return {q: rx, r: rz};
}

// -------- drawing ----------
function draw(){
  // background fill
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#c6f2b6';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw tiles
  for (const k in grid){
    const tile = grid[k];
    const pos = hexToPixel(tile.q, tile.r);
    drawHex(pos.x, pos.y, hexSize * DPR - 6, tile);
  }

  // draw units on top
  for (const id in enemies){
    const u = enemies[id];
    const pos = hexToPixel(u.q, u.r);
    drawEnemy(pos.x, pos.y, hexSize * DPR - 12);
  }
  for (const k in defenders){
    const p = parseKey(k);
    const pos = hexToPixel(p.q, p.r);
    drawDefender(pos.x, pos.y, hexSize * DPR - 12);
  }

  // optional: draw center highlight
  const center = hexToPixel(0,0);
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(center.x, center.y, 4 * DPR, 0, Math.PI*2);
  ctx.stroke();

  // update HUD
  defCountEl.textContent = Object.keys(defenders).length;
  enemyCountEl.textContent = Object.keys(enemies).length;
}

function drawHex(x,y,r,tile){
  // tile base - a slightly 3D polygon (flat shading)
  const corners = [];
  const angleOffset = Math.PI/6; // pointy top
  for (let i=0;i<6;i++){
    const ang = angleOffset + i * Math.PI/3;
    corners.push({x: x + Math.cos(ang)*r, y: y + Math.sin(ang)*r});
  }
  // face
  ctx.fillStyle = tile.type === 'empty' ? '#fff' : '#fff';
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  for (let i=1;i<6;i++) ctx.lineTo(corners[i].x, corners[i].y);
  ctx.closePath();
  ctx.fill();

  // top highlight (simulate low-poly facets)
  ctx.fillStyle = 'rgba(230,180,120,0.12)';
  ctx.beginPath();
  ctx.moveTo(corners[0].x, corners[0].y);
  ctx.lineTo(corners[1].x, corners[1].y);
  ctx.lineTo(x, y);
  ctx.closePath();
  ctx.fill();

  // edge
  ctx.lineWidth = 4 * DPR;
  ctx.strokeStyle = 'rgba(0,0,0,0.06)';
  ctx.stroke();

  // small shadow for outer ring
  const dist = hexDistance({q:tile.q,r:tile.r},{q:0,r:0});
  if (dist === gridRadius) {
    ctx.fillStyle = 'rgba(0,0,0,0.02)';
    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y);
    for (let i=1;i<6;i++) ctx.lineTo(corners[i].x, corners[i].y);
    ctx.closePath();
    ctx.fill();
  }
}

function drawDefender(x,y,r){
  // stylized low-poly defender: orange torso + small head + beard
  ctx.save();
  // torso (hex-ish oval)
  ctx.beginPath();
  ctx.ellipse(x, y + r*0.06, r*0.58, r*0.7, 0, 0, Math.PI*2);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--defender') || '#ff8a3d';
  ctx.fill();

  // head
  ctx.beginPath();
  ctx.arc(x, y - r*0.38, r*0.28, 0, Math.PI*2);
  ctx.fillStyle = '#ffdbb6';
  ctx.fill();

  // beard / mask
  ctx.fillStyle = '#2b1b12';
  ctx.fillRect(x - r*0.12, y - r*0.3, r*0.24, r*0.20);
  // arms (simple)
  ctx.fillStyle = '#2b1b12';
  ctx.fillRect(x - r*0.6, y + r*0.1, r*0.18, r*0.08);
  ctx.fillRect(x + r*0.42, y + r*0.1, r*0.18, r*0.08);

  ctx.restore();
}

function drawEnemy(x,y,r){
  // darker/red enemy in similar low-poly style
  ctx.save();
  ctx.beginPath();
  ctx.ellipse(x, y + r*0.06, r*0.58, r*0.7, 0, 0, Math.PI*2);
  ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--enemy') || '#b95a3a';
  ctx.fill();

  ctx.beginPath();
  ctx.arc(x, y - r*0.38, r*0.28, 0, Math.PI*2);
  ctx.fillStyle = '#f2d2b4';
  ctx.fill();

  // dark mouth/beard
  ctx.fillStyle = '#2b1b12';
  ctx.fillRect(x - r*0.12, y - r*0.3, r*0.24, r*0.20);

  ctx.restore();
}

// ---------- gameplay ----------
function spawnWave(count=12){
  // place enemies randomly on outer ring tiles that are empty
  const outer = [];
  for (const k in grid){
    const t = grid[k];
    if (hexDistance({q:t.q,r:t.r},{q:0,r:0}) === gridRadius){
      outer.push(t);
    }
  }
  // shuffle
  for (let i=outer.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [outer[i], outer[j]] = [outer[j], outer[i]];
  }
  let placed = 0;
  for (let t of outer){
    if (placed >= count) break;
    const k = key(t.q,t.r);
    // don't spawn where defender exists (shouldn't)
    if (!defenders[k]){
      const id = nextEnemyId++;
      enemies[id] = {q:t.q, r:t.r};
      placed++;
    }
  }
  draw();
  // start tick if not running
  if (!tickTimer) tickTimer = setInterval(tick, tickInterval);
}
function resetGame(){
  buildGrid();
  overlay.classList.remove('show');
  if (tickTimer){ clearInterval(tickTimer); tickTimer = null; }
  running = true;
  draw();
}
function tick(){
  if (!running) return;
  // move each enemy one step towards center (0,0), blocking if target occupied by defender or another enemy
  const moves = {}; // id -> new q,r
  for (const id in enemies){
    const e = enemies[id];
    // if already at center -> lose
    if (e.q === 0 && e.r === 0){ onLose(); return; }

    // compute neighbor that reduces distance to center
    let best = {q: e.q, r: e.r};
    let bestDist = hexDistance({q:e.q,r:e.r},{q:0,r:0});
    for (const n of NEI){
      const nq = e.q + n[0];
      const nr = e.r + n[1];
      // must exist in grid
      if (!grid.hasOwnProperty(key(nq,nr))) continue;
      // if a defender occupies that hex, can't move into it
      if (defenders[key(nq,nr)]) continue;
      // also check other enemies planned to move there
      let occupiedByOtherPlanned = false;
      for (const mid in enemies){
        if (mid === id) continue;
        // if other enemy is currently at target and not moving out (we don't track who moves first), disallow
        const other = enemies[mid];
        if (other.q === nq && other.r === nr) occupiedByOtherPlanned = true;
      }
      if (occupiedByOtherPlanned) continue;
      const dist = hexDistance({q:nq,r:nr},{q:0,r:0});
      if (dist < bestDist){ bestDist = dist; best = {q:nq, r:nr}; }
    }
    moves[id] = best;
  }

  // commit moves: if any move puts enemy on center -> lose
  // also prevent collisions: if multiple enemies target same tile, pick one (first) and others stay
  const targetMap = {};
  for (const id in moves){
    const t = moves[id];
    const tk = key(t.q, t.r);
    if (!targetMap[tk]) { targetMap[tk] = id; }
    else {
      // collision: keep existing, this one stays
      moves[id] = {q: enemies[id].q, r: enemies[id].r};
    }
  }
  // apply
  for (const id in moves){
    enemies[id].q = moves[id].q;
    enemies[id].r = moves[id].r;
    if (enemies[id].q === 0 && enemies[id].r === 0){ onLose(); return; }
  }

  draw();
}

function onLose(){
  running = false;
  overlay.classList.add('show');
  if (tickTimer){ clearInterval(tickTimer); tickTimer = null; }
}

// ---------- mouse interaction ----------
canvas.addEventListener('pointerdown', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const px = (ev.clientX - rect.left) * DPR;
  const py = (ev.clientY - rect.top) * DPR;
  const h = pixelToHex(px, py);
  // validate within grid
  if (!grid.hasOwnProperty(key(h.q, h.r))) return;
  const k = key(h.q, h.r);

  // clicking center does nothing
  if (h.q === 0 && h.r === 0) return;

  // toggle defender on tile if empty & limit not exceeded
  if (defenders[k]) {
    delete defenders[k];
  } else {
    if (Object.keys(defenders).length >= maxDefenders) {
      // flash or feedback
      // small shake by temporarily decreasing max size
      return;
    }
    defenders[k] = true;
  }
  draw();
});

// keyboard shortcuts
window.addEventListener('keydown', (e)=>{
  if (e.key === 'r') resetGame();
  if (e.key === ' ') spawnWave(12);
});

// controls
spawnBtn.addEventListener('click', ()=> spawnWave(12));
resetBtn.addEventListener('click', resetGame);

// init
buildGrid();
resizeCanvas();
draw();
</script>
</body>
</html>